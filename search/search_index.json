{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Projectile Motion Projectile motion follows Newton's laws under constant acceleration due to gravity. The basic equations for a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) from the horizontal are: Equations of Motion Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion under gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Time of Flight The total time of flight can be found by setting \\( y(t) = 0 \\) (when the projectile returns to the ground): $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range of the Projectile The horizontal range is given by: $$ R = v_0 \\cos(\\theta) \\cdot t_f $$ Substituting \\( t_f \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on both the initial velocity and the launch angle. 2. Analysis of the Range The maximum range occurs when \\( \\sin(2\\theta) = 1 \\) , i.e., at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases the range quadratically. Increasing \\( g \\) (e.g., on planets with stronger gravity) decreases the range. 3. Practical Applications Sports : Optimization of throwing angles in javelin, shot put, and soccer. Engineering : Ballistics and missile trajectory predictions. Astrophysics : Calculations for planetary landings, where gravity varies. 4. Implementation in Python ```python import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees Compute range for each angle ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g Find the angle with the maximum range optimal_angle = angles[np.argmax(ranges)] max_range = max(ranges) Plot plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=\"Projectile Range\") plt.axvline(x=optimal_angle, color='r', linestyle=\"--\", label=f\"Max Range at {optimal_angle:.1f}\u00b0\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() print(f\"Maximum range of {max_range:.2f} meters occurs at {optimal_angle:.1f} degrees.\")","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-projectile-motion","text":"Projectile motion follows Newton's laws under constant acceleration due to gravity. The basic equations for a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) from the horizontal are:","title":"Governing Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion under gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The total time of flight can be found by setting \\( y(t) = 0 \\) (when the projectile returns to the ground): $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The horizontal range is given by: $$ R = v_0 \\cos(\\theta) \\cdot t_f $$ Substituting \\( t_f \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on both the initial velocity and the launch angle.","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The maximum range occurs when \\( \\sin(2\\theta) = 1 \\) , i.e., at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases the range quadratically. Increasing \\( g \\) (e.g., on planets with stronger gravity) decreases the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimization of throwing angles in javelin, shot put, and soccer. Engineering : Ballistics and missile trajectory predictions. Astrophysics : Calculations for planetary landings, where gravity varies.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#compute-range-for-each-angle","text":"ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g","title":"Compute range for each angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#find-the-angle-with-the-maximum-range","text":"optimal_angle = angles[np.argmax(ranges)] max_range = max(ranges)","title":"Find the angle with the maximum range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot","text":"plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=\"Projectile Range\") plt.axvline(x=optimal_angle, color='r', linestyle=\"--\", label=f\"Max Range at {optimal_angle:.1f}\u00b0\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() print(f\"Maximum range of {max_range:.2f} meters occurs at {optimal_angle:.1f} degrees.\")","title":"Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega_d \\) is the driving frequency. For small angles, we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega_d t) \\] Resonance and Energy Considerations Resonance occurs when the driving frequency matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ The energy in the system fluctuates due to damping and external forcing, leading to phenomena such as periodic, quasiperiodic, and chaotic motion. 2. Implementation in Python ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega_d = 2.0 # driving frequency Differential equation for the forced damped pendulum def forced_damped_pendulum(t, y, b, A, omega_d): theta, omega = y dydt = [ omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega_d \\) is the driving frequency. For small angles, we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega_d t) \\]","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-energy-considerations","text":"Resonance occurs when the driving frequency matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ The energy in the system fluctuates due to damping and external forcing, leading to phenomena such as periodic, quasiperiodic, and chaotic motion.","title":"Resonance and Energy Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-implementation-in-python","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"2. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega_d = 2.0 # driving frequency","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation-for-the-forced-damped-pendulum","text":"def forced_damped_pendulum(t, y, b, A, omega_d): theta, omega = y dydt = [ omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(","title":"Differential equation for the forced damped pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation Kepler\u2019s Third Law Kepler\u2019s Third Law states that for a body orbiting another in a circular orbit, the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( R \\) : where: - \\( T \\) is the orbital period, - \\( R \\) is the orbital radius, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. Rearranging for \\( T \\) : \\[ T = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] This equation shows that the orbital period increases with the radius. 2. Real-World Implications Determining planetary masses: By measuring the period and radius of a moon orbiting a planet, the mass of the planet can be calculated. Satellite Orbits: Engineers use Kepler\u2019s laws to design stable orbits for communication and GPS satellites. Exoplanet Discovery: Astronomers use Kepler\u2019s Third Law to estimate the distance and mass of exoplanets by analyzing their orbital periods. 3. Implementation in Python import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R_values = np.linspace(7e6, 4e8, 100) # Orbital radii from 7,000 km to 400,000 km # Calculate orbital periods T_values = 2 * np.pi * np.sqrt(R_values**3 / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(8, 5)) plt.plot(R_values**3, T_values**2, label='$T^2 \\propto R^3$', color='b') plt.xlabel('$R^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title('Kepler\u2019s Third Law: $T^2$ vs $R^3$') plt.legend() plt.grid() plt.show() 4. Discussion on Extensions Elliptical Orbits: While this derivation assumes circular orbits, Kepler\u2019s Third Law extends to elliptical orbits by using the semi-major axis instead of \\( R \\) . Gravitational Interactions: Multi-body systems introduce perturbations that modify orbital periods slightly. Relativistic Effects: At very high masses or velocities, general relativity modifies the gravitational interactions beyond Newtonian predictions. 5. Conclusion This analysis confirms Kepler\u2019s Third Law through theoretical derivation and computational modeling. The relationship between \\( T^2 \\) and \\( R^3 \\) is essential in astronomy, satellite mechanics, and astrophysics, providing a fundamental link between motion and gravity.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler\u2019s Third Law states that for a body orbiting another in a circular orbit, the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( R \\) : where: - \\( T \\) is the orbital period, - \\( R \\) is the orbital radius, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. Rearranging for \\( T \\) : \\[ T = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] This equation shows that the orbital period increases with the radius.","title":"Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-implications","text":"Determining planetary masses: By measuring the period and radius of a moon orbiting a planet, the mass of the planet can be calculated. Satellite Orbits: Engineers use Kepler\u2019s laws to design stable orbits for communication and GPS satellites. Exoplanet Discovery: Astronomers use Kepler\u2019s Third Law to estimate the distance and mass of exoplanets by analyzing their orbital periods.","title":"2. Real-World Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R_values = np.linspace(7e6, 4e8, 100) # Orbital radii from 7,000 km to 400,000 km # Calculate orbital periods T_values = 2 * np.pi * np.sqrt(R_values**3 / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(8, 5)) plt.plot(R_values**3, T_values**2, label='$T^2 \\propto R^3$', color='b') plt.xlabel('$R^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title('Kepler\u2019s Third Law: $T^2$ vs $R^3$') plt.legend() plt.grid() plt.show()","title":"3. Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-discussion-on-extensions","text":"Elliptical Orbits: While this derivation assumes circular orbits, Kepler\u2019s Third Law extends to elliptical orbits by using the semi-major axis instead of \\( R \\) . Gravitational Interactions: Multi-body systems introduce perturbations that modify orbital periods slightly. Relativistic Effects: At very high masses or velocities, general relativity modifies the gravitational interactions beyond Newtonian predictions.","title":"4. Discussion on Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"This analysis confirms Kepler\u2019s Third Law through theoretical derivation and computational modeling. The relationship between \\( T^2 \\) and \\( R^3 \\) is essential in astronomy, satellite mechanics, and astrophysics, providing a fundamental link between motion and gravity.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"# Problem 2 # \ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities \ud83c\udfaf Motivation Space travel depends critically on understanding the gravitational forces of celestial bodies and the energy required to overcome them. Concepts such as escape velocity and cosmic velocities define the speed thresholds necessary for different types of motion \u2014 from stable orbiting to escaping a planet, or even a solar system entirely. These are not just theoretical physics concepts, but real-world tools used in designing missions, launching satellites, planning interplanetary trips, and one day \u2014 perhaps \u2014 achieving interstellar travel. \ud83c\udf0d Definitions of Cosmic Velocities In classical mechanics and astrodynamics, three main types of \"cosmic velocities\" are defined, each corresponding to a specific threshold in orbital mechanics: 1. \ud83d\udef0\ufe0f First Cosmic Velocity ( \\(v_1\\) ) \u2013 Orbital Velocity Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body (ignoring atmosphere). Physical Interpretation: If a spacecraft reaches this velocity tangential to the surface, it will fall around the planet instead of onto it \u2014 achieving orbit. Formula: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body (kg) \\(R\\) is the radius of the celestial body (m) 2. \ud83d\ude80 Second Cosmic Velocity ( \\(v_2\\) ) \u2013 Escape Velocity Definition: The minimum velocity required to completely escape the gravitational pull of a celestial body without further propulsion. Physical Interpretation: At this velocity, the total mechanical energy (kinetic + potential) of the spacecraft becomes zero \u2014 it can reach infinity with zero velocity. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 $$ 3. \ud83c\udf0c Third Cosmic Velocity ( \\(v_3\\) ) \u2013 Interstellar Escape Velocity Definition: The speed needed to escape both the planet\u2019s gravity and the gravity of its parent star (e.g., the Sun), and leave the solar system. Physical Interpretation: A spacecraft launched from Earth would need additional energy to escape not only Earth\u2019s gravity but also the Sun\u2019s gravitational influence. Note: \\(v_3\\) depends on the orbital velocity of the planet around the star and the relative direction of launch (same or opposite to orbital motion). It's generally derived from the total energy needed to reach the star system\u2019s edge. \ud83d\udcd0 Mathematical Background Gravitational Potential Energy: \\[ U = -\\frac{GMm}{r} \\] Kinetic Energy: \\[ K = \\frac{1}{2}mv^2 \\] Setting total mechanical energy \\(E = K + U = 0\\) gives the escape condition: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} $$ This is the essence of escape velocity ( \\(v_2\\) ). For orbital motion, we only need to balance centripetal and gravitational forces: $$ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} = v_1 $$ \ud83c\udf0d Cosmic Velocity Calculations To calculate the first and second cosmic velocities , we use the following physics equations: First Cosmic Velocity (circular orbit velocity): \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (escape velocity): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Where: \\( G \\) is the universal gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2} \\) \\( M \\) is the mass of the celestial body (in kg) \\( R \\) is the radius of the celestial body (in meters) We apply these formulas to the following celestial bodies: - \ud83c\udf0d Earth - \u2642\ufe0f Mars - \u2643 Jupiter The resulting velocities are visualized using bar charts to compare the gravitational environments of each planet.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Space travel depends critically on understanding the gravitational forces of celestial bodies and the energy required to overcome them. Concepts such as escape velocity and cosmic velocities define the speed thresholds necessary for different types of motion \u2014 from stable orbiting to escaping a planet, or even a solar system entirely. These are not just theoretical physics concepts, but real-world tools used in designing missions, launching satellites, planning interplanetary trips, and one day \u2014 perhaps \u2014 achieving interstellar travel.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"In classical mechanics and astrodynamics, three main types of \"cosmic velocities\" are defined, each corresponding to a specific threshold in orbital mechanics:","title":"\ud83c\udf0d Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1-orbital-velocity","text":"Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body (ignoring atmosphere). Physical Interpretation: If a spacecraft reaches this velocity tangential to the surface, it will fall around the planet instead of onto it \u2014 achieving orbit. Formula: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body (kg) \\(R\\) is the radius of the celestial body (m)","title":"1. \ud83d\udef0\ufe0f First Cosmic Velocity (\\(v_1\\)) \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity","text":"Definition: The minimum velocity required to completely escape the gravitational pull of a celestial body without further propulsion. Physical Interpretation: At this velocity, the total mechanical energy (kinetic + potential) of the spacecraft becomes zero \u2014 it can reach infinity with zero velocity. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 $$","title":"2. \ud83d\ude80 Second Cosmic Velocity (\\(v_2\\)) \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-interstellar-escape-velocity","text":"Definition: The speed needed to escape both the planet\u2019s gravity and the gravity of its parent star (e.g., the Sun), and leave the solar system. Physical Interpretation: A spacecraft launched from Earth would need additional energy to escape not only Earth\u2019s gravity but also the Sun\u2019s gravitational influence. Note: \\(v_3\\) depends on the orbital velocity of the planet around the star and the relative direction of launch (same or opposite to orbital motion). It's generally derived from the total energy needed to reach the star system\u2019s edge.","title":"3. \ud83c\udf0c Third Cosmic Velocity (\\(v_3\\)) \u2013 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-background","text":"","title":"\ud83d\udcd0 Mathematical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-potential-energy","text":"\\[ U = -\\frac{GMm}{r} \\]","title":"Gravitational Potential Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#kinetic-energy","text":"\\[ K = \\frac{1}{2}mv^2 \\] Setting total mechanical energy \\(E = K + U = 0\\) gives the escape condition: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} $$ This is the essence of escape velocity ( \\(v_2\\) ). For orbital motion, we only need to balance centripetal and gravitational forces: $$ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} = v_1 $$","title":"Kinetic Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocity-calculations","text":"To calculate the first and second cosmic velocities , we use the following physics equations: First Cosmic Velocity (circular orbit velocity): \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (escape velocity): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Where: \\( G \\) is the universal gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2} \\) \\( M \\) is the mass of the celestial body (in kg) \\( R \\) is the radius of the celestial body (in meters) We apply these formulas to the following celestial bodies: - \ud83c\udf0d Earth - \u2642\ufe0f Mars - \u2643 Jupiter The resulting velocities are visualized using bar charts to compare the gravitational environments of each planet.","title":"\ud83c\udf0d Cosmic Velocity Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth \ud83c\udfaf Motivation When a payload is released from a spacecraft near Earth, its future motion depends entirely on its initial conditions \u2014 position, velocity, and the local gravitational field. The resulting path may be: A suborbital fall back to Earth, A stable circular or elliptical orbit , A parabolic path (exact escape), Or a hyperbolic trajectory (true escape from Earth's gravity). Understanding and predicting these trajectories is critical for: Designing satellite deployments, Planning reentry operations, Performing interplanetary injections. \ud83d\udcd0 Physical Background We assume that the only force acting on the payload is Earth's gravity , modeled by Newton's Law of Universal Gravitation . Newton's Law of Gravitation: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2 \\) is the gravitational constant, \\( M \\) is the mass of the Earth, \\( m \\) is the mass of the payload, \\( r \\) is the distance from the Earth's center, \\( \\hat{r} \\) is the unit vector pointing from the payload toward the center of Earth. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] Thus, the acceleration depends only on position, not mass \u2014 so the trajectory is independent of the payload's mass . \ud83e\udde0 Theoretical Velocity Thresholds Let \\( R \\) be Earth's radius and \\( h \\) the altitude of release. Then the radial distance is: \\[ r = R + h \\] We define three key velocity thresholds at altitude \\( r \\) : 1. Circular Orbit Velocity: The velocity needed to maintain a circular orbit at radius \\( r \\) : \\[ v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}} \\] 2. Escape Velocity: The minimum velocity needed to escape Earth\u2019s gravity (assuming no further propulsion): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\cdot v_{\\text{circular}} \\] \ud83e\uddee Numerical Simulation Using numerical integration (e.g., Runge-Kutta method via scipy.integrate.solve_ivp ), we simulate the path of the payload for various initial velocities and directions. Initial Conditions: Altitude: \\( h = 300\\,\\text{km} \\) Initial position: \\( [r_0, 0] \\) Initial velocities: Suborbital : \\( v < v_{\\text{circular}} \\) Circular Orbit : \\( v = v_{\\text{circular}} \\) Escape : \\( v \\geq v_{\\text{escape}} \\) \ud83d\udcbb Python Implementation (Sample Code) ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay] Initial altitude altitude = 300e3 r0 = R + altitude Velocity thresholds v_circular = np.sqrt(G * M / r0) v_escape = np.sqrt(2) * v_circular Scenarios scenarios = { \"Suborbital\": [r0, 0, 0, 5000], \"Circular Orbit\": [r0, 0, 0, v_circular], \"Escape Trajectory\": [r0, 0, 0, v_escape] } Time and simulation t_span = (0, 10000) t_eval = np.linspace(*t_span, 2000) Plotting plt.figure(figsize=(10, 10)) for label, state0 in scenarios.items(): sol = solve_ivp(gravity, t_span, state0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[1] plt.plot(x / 1000, y / 1000, label=label) Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1000 earth_y = R * np.sin(theta) / 1000 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') plt.title(\"Trajectories of a Freely Released Payload\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its future motion depends entirely on its initial conditions \u2014 position, velocity, and the local gravitational field. The resulting path may be: A suborbital fall back to Earth, A stable circular or elliptical orbit , A parabolic path (exact escape), Or a hyperbolic trajectory (true escape from Earth's gravity). Understanding and predicting these trajectories is critical for: Designing satellite deployments, Planning reentry operations, Performing interplanetary injections.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-background","text":"We assume that the only force acting on the payload is Earth's gravity , modeled by Newton's Law of Universal Gravitation .","title":"\ud83d\udcd0 Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2 \\) is the gravitational constant, \\( M \\) is the mass of the Earth, \\( m \\) is the mass of the payload, \\( r \\) is the distance from the Earth's center, \\( \\hat{r} \\) is the unit vector pointing from the payload toward the center of Earth. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] Thus, the acceleration depends only on position, not mass \u2014 so the trajectory is independent of the payload's mass .","title":"Newton's Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-velocity-thresholds","text":"Let \\( R \\) be Earth's radius and \\( h \\) the altitude of release. Then the radial distance is: \\[ r = R + h \\] We define three key velocity thresholds at altitude \\( r \\) :","title":"\ud83e\udde0 Theoretical Velocity Thresholds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-circular-orbit-velocity","text":"The velocity needed to maintain a circular orbit at radius \\( r \\) : \\[ v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}} \\]","title":"1. Circular Orbit Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-escape-velocity","text":"The minimum velocity needed to escape Earth\u2019s gravity (assuming no further propulsion): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\cdot v_{\\text{circular}} \\]","title":"2. Escape Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Using numerical integration (e.g., Runge-Kutta method via scipy.integrate.solve_ivp ), we simulate the path of the payload for various initial velocities and directions.","title":"\ud83e\uddee Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Altitude: \\( h = 300\\,\\text{km} \\) Initial position: \\( [r_0, 0] \\) Initial velocities: Suborbital : \\( v < v_{\\text{circular}} \\) Circular Orbit : \\( v = v_{\\text{circular}} \\) Escape : \\( v \\geq v_{\\text{escape}} \\)","title":"Initial Conditions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation-sample-code","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"\ud83d\udcbb Python Implementation (Sample Code)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-acceleration","text":"def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay]","title":"Gravitational acceleration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-altitude","text":"altitude = 300e3 r0 = R + altitude","title":"Initial altitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#velocity-thresholds","text":"v_circular = np.sqrt(G * M / r0) v_escape = np.sqrt(2) * v_circular","title":"Velocity thresholds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#scenarios","text":"scenarios = { \"Suborbital\": [r0, 0, 0, 5000], \"Circular Orbit\": [r0, 0, 0, v_circular], \"Escape Trajectory\": [r0, 0, 0, v_escape] }","title":"Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-and-simulation","text":"t_span = (0, 10000) t_eval = np.linspace(*t_span, 2000)","title":"Time and simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting","text":"plt.figure(figsize=(10, 10)) for label, state0 in scenarios.items(): sol = solve_ivp(gravity, t_span, state0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[1] plt.plot(x / 1000, y / 1000, label=label)","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/#earth","text":"theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1000 earth_y = R * np.sin(theta) / 1000 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') plt.title(\"Trajectories of a Freely Released Payload\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when circular ripples from different points meet, forming regions of amplification (constructive interference) and cancellation (destructive interference). Understanding such patterns deepens our grasp of wave behavior, coherence, and phase relationships. In this study, we place point sources at the vertices of a regular polygon to explore interference using wave superposition. Problem Setup We simulate wave interference from 5 coherent point sources placed at the vertices of a regular pentagon . Each source emits circular waves with the same amplitude, frequency, and wavelength. Wave Equation A circular wave from a point source at \\((x_i, y_i)\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source \\(i\\) The total wave displacement is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] Assumptions Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) All waves are coherent (same phase) Regular pentagon centered at the origin Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength frequency = 1.0 # Frequency k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency t = 0 # Time (snapshot) # Polygon settings N = 5 # Number of sources (regular pentagon) radius = 3.0 # Distance from center to each vertex # Generate source positions (vertices of regular polygon) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid for simulation x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate total wave displacement Psi = np.zeros_like(X) for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) Psi += A * np.cos(k * r - omega * t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Psi, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Wave Sources') plt.title(\"Interference Pattern from 5 Point Sources (Pentagon)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when circular ripples from different points meet, forming regions of amplification (constructive interference) and cancellation (destructive interference). Understanding such patterns deepens our grasp of wave behavior, coherence, and phase relationships. In this study, we place point sources at the vertices of a regular polygon to explore interference using wave superposition.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"We simulate wave interference from 5 coherent point sources placed at the vertices of a regular pentagon . Each source emits circular waves with the same amplitude, frequency, and wavelength.","title":"Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"A circular wave from a point source at \\((x_i, y_i)\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source \\(i\\) The total wave displacement is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions","text":"Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) All waves are coherent (same phase) Regular pentagon centered at the origin","title":"Assumptions"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength frequency = 1.0 # Frequency k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency t = 0 # Time (snapshot) # Polygon settings N = 5 # Number of sources (regular pentagon) radius = 3.0 # Distance from center to each vertex # Generate source positions (vertices of regular polygon) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid for simulation x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate total wave displacement Psi = np.zeros_like(X) for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) Psi += A * np.cos(k * r - omega * t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Psi, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Wave Sources') plt.title(\"Interference Pattern from 5 Point Sources (Pentagon)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Understanding this force is crucial in many real-world systems: - Cyclotrons accelerate particles using magnetic fields. - Mass spectrometers measure mass-to-charge ratios via curved paths. - Plasma confinement in tokamaks uses magnetic fields to control hot ionized gases. Simulating this numerically reveals how different field configurations affect particle motion \u2014 circular orbits, helices, or E\u00d7B drift. Applications of the Lorentz Force Particle Accelerators : Use strong magnetic fields to bend and focus particles (e.g., LHC). Mass Spectrometry : Ions are separated by curvature of their path (depends on m/q). Fusion Reactors (Tokamaks) : Magnetic fields confine hot plasma using helical motion. Auroras : Charged solar particles spiral along Earth's magnetic field. Electric fields ( \\(\\vec{E}\\) ) add linear acceleration, while magnetic fields ( \\(\\vec{B}\\) ) bend paths into spirals or circles. Simulation of Particle Motion We simulate using the Lorentz force law and integrate using Euler's method . Scenarios: Only \\(\\vec{B}\\) : Circular or helical motion \\(\\vec{E}\\) and \\(\\vec{B}\\) : Complex curves or drifts Crossed \\(\\vec{E} \\perp \\vec{B}\\) : E\u00d7B drift Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (along z) # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Lists to store trajectory trajectory = [r.copy()] # Euler integration loop for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) # Convert to array trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2], label='Particle Path') ax.set_title('Charged Particle Trajectory (Lorentz Force)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.legend() plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Understanding this force is crucial in many real-world systems: - Cyclotrons accelerate particles using magnetic fields. - Mass spectrometers measure mass-to-charge ratios via curved paths. - Plasma confinement in tokamaks uses magnetic fields to control hot ionized gases. Simulating this numerically reveals how different field configurations affect particle motion \u2014 circular orbits, helices, or E\u00d7B drift.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Particle Accelerators : Use strong magnetic fields to bend and focus particles (e.g., LHC). Mass Spectrometry : Ions are separated by curvature of their path (depends on m/q). Fusion Reactors (Tokamaks) : Magnetic fields confine hot plasma using helical motion. Auroras : Charged solar particles spiral along Earth's magnetic field. Electric fields ( \\(\\vec{E}\\) ) add linear acceleration, while magnetic fields ( \\(\\vec{B}\\) ) bend paths into spirals or circles.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-of-particle-motion","text":"We simulate using the Lorentz force law and integrate using Euler's method .","title":"Simulation of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios","text":"Only \\(\\vec{B}\\) : Circular or helical motion \\(\\vec{E}\\) and \\(\\vec{B}\\) : Complex curves or drifts Crossed \\(\\vec{E} \\perp \\vec{B}\\) : E\u00d7B drift","title":"Scenarios:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (along z) # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Lists to store trajectory trajectory = [r.copy()] # Euler integration loop for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) # Convert to array trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2], label='Particle Path') ax.set_title('Charged Particle Trajectory (Lorentz Force)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.legend() plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Electrical circuits often consist of a complex arrangement of resistors connected in series , parallel , or even in more complicated networks with loops and branches . Calculating the equivalent resistance between two terminals is a fundamental task in both theoretical and applied physics and electrical engineering. While simple circuits can be reduced manually, larger or irregular networks quickly become tedious and error-prone to simplify by hand. This is where graph theory comes in. By representing the circuit as a weighted undirected graph , we can approach the problem in a structured and algorithmic way. Using Python and NetworkX , we can: Model any resistor network Systematically simplify it using graph transformations Visualize each reduction step Compute the final equivalent resistance programmatically Theoretical Background We base our approach on two fundamental rules from circuit analysis: 1. Series Resistance Two resistors connected end-to-end , where no other branches exist at the node in between, can be replaced with a single resistor: \\[ R_{\\text{eq}} = R_1 + R_2 \\] This applies when the node between the two resistors has degree 2 and is not a source or target. 2. Parallel Resistance When multiple resistors connect the same pair of nodes , they are in parallel. They can be replaced by a single resistor using: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Or in code: \\[ R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1} \\] These rules are sufficient to reduce any purely resistive network, provided the network is connected and has no dependent elements (like voltage/current sources or reactive components). Algorithm Description We use a step-by-step simplification strategy: Input : A weighted, undirected graph where: Nodes represent junctions Edges represent resistors with a 'resistance' attribute Reduction Loop : Find nodes (excluding terminals) with degree 2 \u2192 Apply series rule Find multiple edges between any pair of nodes \u2192 Apply parallel rule Continue simplification until no more changes are possible. The resulting edge between source and target contains the equivalent resistance. Python Implementation We implement the reduction rules in Python using the networkx library. import networkx as nx def reduce_series(G, node, source, target): if G.degree(node) != 2 or node in [source, target]: return False neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) return True def reduce_parallel(G): reduced = False edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: key = frozenset({u, v}) if key in seen: continue parallels = [d['resistance'] for _, _, d in G.edges(u, v, data=True)] if len(parallels) > 1: R_eq = 1 / sum(1 / r for r in parallels) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=R_eq) reduced = True seen.add(key) return reduced def equivalent_resistance(G, source, target): G = G.copy() while True: reduced = False for node in list(G.nodes): reduced |= reduce_series(G, node, source, target) reduced |= reduce_parallel(G) if not reduced: break return G[source][target]['resistance'] Python Code for the Plot import networkx as nx import matplotlib.pyplot as plt def plot_circuit_graph(edges): \"\"\" Plot a circuit graph using networkx. Parameters: - edges: list of tuples (node1, node2, resistance_value) \"\"\" G = nx.Graph() for u, v, r in edges: G.add_edge(u, v, weight=r, label=f'{r}\u03a9') pos = nx.spring_layout(G, seed=42) # Layout for positioning edge_labels = nx.get_edge_attributes(G, 'label') # Draw nodes and edges nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Circuit Graph (Resistance in \u03a9)\", fontsize=14) plt.axis('off') plt.show() # Example 1: Simple Series Circuit A - B - C with resistances 2\u03a9 and 3\u03a9 edges_example_1 = [ ('A', 'B', 2), ('B', 'C', 3) ] # Example 2: Simple Parallel Circuit A - B and A - C - B edges_example_2 = [ ('A', 'B', 4), ('A', 'C', 2), ('C', 'B', 2) ] # Example 3: Nested Configuration edges_example_3 = [ ('A', 'B', 3), ('B', 'C', 2), ('C', 'D', 2), ('A', 'D', 6) ] # Choose the example to visualize plot_circuit_graph(edges_example_3)","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Electrical circuits often consist of a complex arrangement of resistors connected in series , parallel , or even in more complicated networks with loops and branches . Calculating the equivalent resistance between two terminals is a fundamental task in both theoretical and applied physics and electrical engineering. While simple circuits can be reduced manually, larger or irregular networks quickly become tedious and error-prone to simplify by hand. This is where graph theory comes in. By representing the circuit as a weighted undirected graph , we can approach the problem in a structured and algorithmic way. Using Python and NetworkX , we can: Model any resistor network Systematically simplify it using graph transformations Visualize each reduction step Compute the final equivalent resistance programmatically","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-background","text":"We base our approach on two fundamental rules from circuit analysis:","title":"Theoretical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-series-resistance","text":"Two resistors connected end-to-end , where no other branches exist at the node in between, can be replaced with a single resistor: \\[ R_{\\text{eq}} = R_1 + R_2 \\] This applies when the node between the two resistors has degree 2 and is not a source or target.","title":"1. Series Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-parallel-resistance","text":"When multiple resistors connect the same pair of nodes , they are in parallel. They can be replaced by a single resistor using: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Or in code: \\[ R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1} \\] These rules are sufficient to reduce any purely resistive network, provided the network is connected and has no dependent elements (like voltage/current sources or reactive components).","title":"2. Parallel Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"We use a step-by-step simplification strategy: Input : A weighted, undirected graph where: Nodes represent junctions Edges represent resistors with a 'resistance' attribute Reduction Loop : Find nodes (excluding terminals) with degree 2 \u2192 Apply series rule Find multiple edges between any pair of nodes \u2192 Apply parallel rule Continue simplification until no more changes are possible. The resulting edge between source and target contains the equivalent resistance.","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"We implement the reduction rules in Python using the networkx library. import networkx as nx def reduce_series(G, node, source, target): if G.degree(node) != 2 or node in [source, target]: return False neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) return True def reduce_parallel(G): reduced = False edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: key = frozenset({u, v}) if key in seen: continue parallels = [d['resistance'] for _, _, d in G.edges(u, v, data=True)] if len(parallels) > 1: R_eq = 1 / sum(1 / r for r in parallels) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=R_eq) reduced = True seen.add(key) return reduced def equivalent_resistance(G, source, target): G = G.copy() while True: reduced = False for node in list(G.nodes): reduced |= reduce_series(G, node, source, target) reduced |= reduce_parallel(G) if not reduced: break return G[source][target]['resistance']","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-for-the-plot","text":"import networkx as nx import matplotlib.pyplot as plt def plot_circuit_graph(edges): \"\"\" Plot a circuit graph using networkx. Parameters: - edges: list of tuples (node1, node2, resistance_value) \"\"\" G = nx.Graph() for u, v, r in edges: G.add_edge(u, v, weight=r, label=f'{r}\u03a9') pos = nx.spring_layout(G, seed=42) # Layout for positioning edge_labels = nx.get_edge_attributes(G, 'label') # Draw nodes and edges nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Circuit Graph (Resistance in \u03a9)\", fontsize=14) plt.axis('off') plt.show() # Example 1: Simple Series Circuit A - B - C with resistances 2\u03a9 and 3\u03a9 edges_example_1 = [ ('A', 'B', 2), ('B', 'C', 3) ] # Example 2: Simple Parallel Circuit A - B and A - C - B edges_example_2 = [ ('A', 'B', 4), ('A', 'C', 2), ('C', 'B', 2) ] # Example 3: Nested Configuration edges_example_3 = [ ('A', 'B', 3), ('B', 'C', 2), ('C', 'D', 2), ('A', 'D', 6) ] # Choose the example to visualize plot_circuit_graph(edges_example_3)","title":"Python Code for the Plot"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem Through Simulations Motivation The Central Limit Theorem (CLT) is a fundamental result in statistics. It states that: The distribution of the sample means of a sufficiently large number of independent samples drawn from any population will be approximately normally distributed , regardless of the population\u2019s original distribution. This simulation demonstrates how the CLT works using three types of population distributions: - Uniform - Exponential - Binomial Simulation Plan 1. Population Distributions We generate large populations from: - Uniform(0, 1) - Exponential(\u03bb = 1) - Binomial(n = 10, p = 0.5) 2. Sampling Distributions For each population: - Take repeated samples of size n = 5, 10, 30, 50 - Repeat sampling 1000 times - Calculate sample means for each trial - Plot histograms of sample means 3. Parameters to Observe Shape convergence : Does it become bell-shaped? Spread : Does variance of sample mean decrease with larger sample sizes? Python Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") # Simulation parameters sample_sizes = [5, 10, 30, 50] num_samples = 1000 population_size = 100000 # Define population generators distributions = { \"Uniform(0, 1)\": np.random.uniform(0, 1, population_size), \"Exponential(\u03bb=1)\": np.random.exponential(1, population_size), \"Binomial(n=10, p=0.5)\": np.random.binomial(10, 0.5, population_size) } # Sampling and visualization for name, population in distributions.items(): plt.figure(figsize=(16, 10)) plt.suptitle(f\"Sampling Distribution of Sample Means\\nPopulation: {name}\", fontsize=16) for i, n in enumerate(sample_sizes): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=True) means.append(np.mean(sample)) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, stat=\"density\", bins=30) plt.title(f\"Sample Size = {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() Observations and Interpretation As sample size increases , the distribution of sample means becomes more bell-shaped , even for highly skewed populations (e.g., exponential). This confirms the Central Limit Theorem : regardless of the original population distribution, the sampling distribution of the mean tends toward a normal distribution . Additionally, the spread (standard deviation) of the sample means decreases with larger sample sizes. This matches the theory that: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] where \\( \\sigma_{\\bar{x}} \\) is the standard deviation of the sample mean.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental result in statistics. It states that: The distribution of the sample means of a sufficiently large number of independent samples drawn from any population will be approximately normally distributed , regardless of the population\u2019s original distribution. This simulation demonstrates how the CLT works using three types of population distributions: - Uniform - Exponential - Binomial","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-plan","text":"","title":"Simulation Plan"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-population-distributions","text":"We generate large populations from: - Uniform(0, 1) - Exponential(\u03bb = 1) - Binomial(n = 10, p = 0.5)","title":"1. Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-distributions","text":"For each population: - Take repeated samples of size n = 5, 10, 30, 50 - Repeat sampling 1000 times - Calculate sample means for each trial - Plot histograms of sample means","title":"2. Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameters-to-observe","text":"Shape convergence : Does it become bell-shaped? Spread : Does variance of sample mean decrease with larger sample sizes?","title":"3. Parameters to Observe"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") # Simulation parameters sample_sizes = [5, 10, 30, 50] num_samples = 1000 population_size = 100000 # Define population generators distributions = { \"Uniform(0, 1)\": np.random.uniform(0, 1, population_size), \"Exponential(\u03bb=1)\": np.random.exponential(1, population_size), \"Binomial(n=10, p=0.5)\": np.random.binomial(10, 0.5, population_size) } # Sampling and visualization for name, population in distributions.items(): plt.figure(figsize=(16, 10)) plt.suptitle(f\"Sampling Distribution of Sample Means\\nPopulation: {name}\", fontsize=16) for i, n in enumerate(sample_sizes): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=True) means.append(np.mean(sample)) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, stat=\"density\", bins=30) plt.title(f\"Sample Size = {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-and-interpretation","text":"As sample size increases , the distribution of sample means becomes more bell-shaped , even for highly skewed populations (e.g., exponential). This confirms the Central Limit Theorem : regardless of the original population distribution, the sampling distribution of the mean tends toward a normal distribution . Additionally, the spread (standard deviation) of the sample means decreases with larger sample sizes. This matches the theory that: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] where \\( \\sigma_{\\bar{x}} \\) is the standard deviation of the sample mean.","title":"Observations and Interpretation"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo simulations use randomness to estimate numerical values or solve mathematical problems. One of the most elegant applications of Monte Carlo methods is estimating the value of \u03c0 through geometric probability . This exercise demonstrates how \u03c0 can be approximated through: - The circle-inside-a-square method - The classical Buffon's Needle problem These simulations connect core ideas from geometry , probability , and numerical computation . PART 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation We place a unit circle inside a square of side length 2: Circle area: $$ A_{\\text{circle}} = \\pi r^2 = \\pi $$ Square area: $$ A_{\\text{square}} = (2r)^2 = 4 $$ Since points are uniformly distributed, the probability that a point falls inside the circle is: $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ Thus, we estimate \u03c0 as: $$ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} $$ 2. Simulation & Code import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points return pi_estimate, x, y, inside # Example n = 5000 pi_val, x, y, inside = estimate_pi_circle(n) Visualization Convergence Analysis trials = [100, 500, 1000, 5000, 10000, 50000] estimates = [estimate_pi_circle(n)[0] for n in trials] plt.plot(trials, estimates, marker='o', label='Estimated \u03c0') plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.title(\"Convergence of \u03c0 Estimation using Circle Method\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() Estimating \u03c0 Using Buffon's Needle Method 1. Theoretical Foundation 1.1 What is Buffon\u2019s Needle Problem? Buffon\u2019s Needle is one of the earliest problems in geometric probability, proposed by the French mathematician Georges-Louis Leclerc, Comte de Buffon in the 18th century. The problem asks: If you drop a needle of length L onto a floor that has parallel lines spaced a distance D apart ( L \u2264 D ), what is the probability that the needle crosses one of the lines? Surprisingly, this probability is related to \u03c0. 1.2 Deriving the Formula Let: - L be the length of the needle - D be the distance between the parallel lines (with L \u2264 D ) - \u03b8 be the acute angle between the needle and the lines (0 \u2264 \u03b8 \u2264 \u03c0/2) - x be the distance from the center of the needle to the nearest line (0 \u2264 x \u2264 D/2) A needle will cross a line if: \\[ x \\leq \\frac{L}{2} \\sin(\\theta) \\] To find the probability \\( P \\) , we integrate over all possible positions and orientations of the needle: \\[ P = \\frac{2L}{\\pi D} \\] Solving for \u03c0 gives: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\] Where: - N is the total number of needle drops - C is the number of times the needle crosses a line 2. Simulation 2.1 Method Randomly choose a center point of the needle between 0 and D/2 (since the problem is symmetric). Randomly generate an angle \u03b8 between 0 and \u03c0/2. Check if the needle crosses a line using: \\[ x \\leq \\frac{L}{2} \\sin(\\theta) \\] Count how many times this condition is satisfied. Estimate \u03c0 using: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\] 3. Python Implementation import numpy as np import matplotlib.pyplot as plt def buffon_needle_simulation(N, L=1.0, D=2.0): assert L <= D, \"Needle length must be less than or equal to line spacing\" # Random needle center distances from nearest line x = np.random.uniform(0, D / 2, N) # Random angles between 0 and \u03c0/2 theta = np.random.uniform(0, np.pi / 2, N) # Check if the needle crosses a line crosses = x <= (L / 2) * np.sin(theta) C = np.count_nonzero(crosses) if C == 0: return np.nan # Avoid division by zero else: pi_estimate = (2 * L * N) / (D * C) return pi_estimate, crosses # Example usage N = 10000 pi_est, crosses = buffon_needle_simulation(N) print(f\"Estimated \u03c0 with {N} trials: {pi_est}\")","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations use randomness to estimate numerical values or solve mathematical problems. One of the most elegant applications of Monte Carlo methods is estimating the value of \u03c0 through geometric probability . This exercise demonstrates how \u03c0 can be approximated through: - The circle-inside-a-square method - The classical Buffon's Needle problem These simulations connect core ideas from geometry , probability , and numerical computation .","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"PART 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We place a unit circle inside a square of side length 2: Circle area: $$ A_{\\text{circle}} = \\pi r^2 = \\pi $$ Square area: $$ A_{\\text{square}} = (2r)^2 = 4 $$ Since points are uniformly distributed, the probability that a point falls inside the circle is: $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ Thus, we estimate \u03c0 as: $$ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} $$","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points return pi_estimate, x, y, inside # Example n = 5000 pi_val, x, y, inside = estimate_pi_circle(n)","title":"2. Simulation &amp; Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"trials = [100, 500, 1000, 5000, 10000, 50000] estimates = [estimate_pi_circle(n)[0] for n in trials] plt.plot(trials, estimates, marker='o', label='Estimated \u03c0') plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.title(\"Convergence of \u03c0 Estimation using Circle Method\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show()","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-buffons-needle-method","text":"","title":"Estimating \u03c0 Using Buffon's Needle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#11-what-is-buffons-needle-problem","text":"Buffon\u2019s Needle is one of the earliest problems in geometric probability, proposed by the French mathematician Georges-Louis Leclerc, Comte de Buffon in the 18th century. The problem asks: If you drop a needle of length L onto a floor that has parallel lines spaced a distance D apart ( L \u2264 D ), what is the probability that the needle crosses one of the lines? Surprisingly, this probability is related to \u03c0.","title":"1.1 What is Buffon\u2019s Needle Problem?"},{"location":"1%20Physics/6%20Statistics/Problem_2/#12-deriving-the-formula","text":"Let: - L be the length of the needle - D be the distance between the parallel lines (with L \u2264 D ) - \u03b8 be the acute angle between the needle and the lines (0 \u2264 \u03b8 \u2264 \u03c0/2) - x be the distance from the center of the needle to the nearest line (0 \u2264 x \u2264 D/2) A needle will cross a line if: \\[ x \\leq \\frac{L}{2} \\sin(\\theta) \\] To find the probability \\( P \\) , we integrate over all possible positions and orientations of the needle: \\[ P = \\frac{2L}{\\pi D} \\] Solving for \u03c0 gives: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\] Where: - N is the total number of needle drops - C is the number of times the needle crosses a line","title":"1.2 Deriving the Formula"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#21-method","text":"Randomly choose a center point of the needle between 0 and D/2 (since the problem is symmetric). Randomly generate an angle \u03b8 between 0 and \u03c0/2. Check if the needle crosses a line using: \\[ x \\leq \\frac{L}{2} \\sin(\\theta) \\] Count how many times this condition is satisfied. Estimate \u03c0 using: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot C} \\]","title":"2.1 Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def buffon_needle_simulation(N, L=1.0, D=2.0): assert L <= D, \"Needle length must be less than or equal to line spacing\" # Random needle center distances from nearest line x = np.random.uniform(0, D / 2, N) # Random angles between 0 and \u03c0/2 theta = np.random.uniform(0, np.pi / 2, N) # Check if the needle crosses a line crosses = x <= (L / 2) * np.sin(theta) C = np.count_nonzero(crosses) if C == 0: return np.nan # Avoid division by zero else: pi_estimate = (2 * L * N) / (D * C) return pi_estimate, crosses # Example usage N = 10000 pi_est, crosses = buffon_needle_simulation(N) print(f\"Estimated \u03c0 with {N} trials: {pi_est}\")","title":"3. Python Implementation"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Problem 1: Measuring Earth's Gravitational Acceleration Using a Pendulum Motivation The acceleration due to gravity \\( g \\) is a cornerstone of classical mechanics. A simple pendulum offers an elegant method to estimate \\( g \\) experimentally, using time measurements of oscillations. This experiment emphasizes: Accurate measurement techniques Statistical uncertainty analysis Comparison of experimental vs theoretical \\( g \\) values Materials String: 1.0\u20131.5 m Weight: key, coin, nut, etc. Stopwatch or smartphone Measuring tape (with known resolution, e.g., 1 cm) Experimental Setup Attach the weight to the string and suspend it from a stable point. Measure the total length \\( L \\) from the suspension point to the center of mass of the weight. Displace the pendulum by a small angle (<15\u00b0) and release. Measure time \\( T_{10} \\) for 10 full oscillations , and repeat this 10 times . Record data and perform statistical analysis. Data Table Trial \\( T_{10} \\) (s) \\( T \\) (s) = \\( \\frac{T_{10}}{10} \\) 1 20.1 2.01 2 19.9 1.99 3 20.0 2.00 4 20.2 2.02 5 20.0 2.00 6 20.1 2.01 7 20.0 2.00 8 20.1 2.01 9 19.8 1.98 10 20.2 2.02 Summary Statistics Mean period: \\[ \\bar{T} = \\frac{1}{n} \\sum_{i=1}^{n} T_i = 2.0040 \\ \\text{s} \\] Standard deviation: \\[ \\sigma = \\sqrt{ \\frac{1}{n - 1} \\sum_{i=1}^{n} (T_i - \\bar{T})^2 } = 0.0126 \\ \\text{s} \\] Uncertainty in the mean period: \\[ \\delta \\bar{T} = \\frac{\\sigma}{\\sqrt{n}} = 0.0040 \\ \\text{s} \\] These results indicate that the measurements are quite consistent. The low standard deviation and uncertainty demonstrate that the data is reliable. Calculations 1. Gravitational Acceleration Using the formula for a simple pendulum: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] Plugging in values: \\( L = 1.000 \\ \\text{m} \\) \\( \\bar{T} = 2.0040 \\ \\text{s} \\) We get: \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0040)^2} \\approx 9.8367 \\ \\text{m/s}^2 \\] 2. Propagation of Uncertainty Let: \\( \\delta L = 0.005 \\ \\text{m} \\) \\( \\delta \\bar{T} = 0.0040 \\ \\text{s} \\) Then: \\[ \\delta g = g \\cdot \\sqrt{ \\left( \\frac{\\delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\delta \\bar{T}}{\\bar{T}} \\right)^2 } \\] \\[ \\delta g \\approx 9.8367 \\cdot \\sqrt{ \\left( \\frac{0.005}{1.000} \\right)^2 + \\left( 2 \\cdot \\frac{0.0040}{2.0040} \\right)^2 } \\approx 0.0614 \\ \\text{m/s}^2 \\] Final Result: \\[ g = 9.84 \\pm 0.06 \\ \\text{m/s}^2 \\] Python Code import numpy as np # Measured times for 10 oscillations (in seconds) T10 = np.array([20.1, 19.9, 20.0, 20.2, 20.0, 20.1, 20.0, 20.1, 19.8, 20.2]) L = 1.000 # pendulum length in meters delta_L = 0.005 # uncertainty in length # Calculations T_single = T10 / 10 T_mean = np.mean(T_single) sigma = np.std(T10, ddof=1) delta_T10 = sigma / np.sqrt(len(T10)) delta_T = delta_T10 / 10 # Gravity and uncertainty g = 4 * np.pi**2 * L / T_mean**2 delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T_mean)**2) print(f\"Mean T = {T_mean:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2 \u00b1 {delta_g:.4f}\")","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-using-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\( g \\) is a cornerstone of classical mechanics. A simple pendulum offers an elegant method to estimate \\( g \\) experimentally, using time measurements of oscillations. This experiment emphasizes: Accurate measurement techniques Statistical uncertainty analysis Comparison of experimental vs theoretical \\( g \\) values","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String: 1.0\u20131.5 m Weight: key, coin, nut, etc. Stopwatch or smartphone Measuring tape (with known resolution, e.g., 1 cm)","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Attach the weight to the string and suspend it from a stable point. Measure the total length \\( L \\) from the suspension point to the center of mass of the weight. Displace the pendulum by a small angle (<15\u00b0) and release. Measure time \\( T_{10} \\) for 10 full oscillations , and repeat this 10 times . Record data and perform statistical analysis.","title":"Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-table","text":"Trial \\( T_{10} \\) (s) \\( T \\) (s) = \\( \\frac{T_{10}}{10} \\) 1 20.1 2.01 2 19.9 1.99 3 20.0 2.00 4 20.2 2.02 5 20.0 2.00 6 20.1 2.01 7 20.0 2.00 8 20.1 2.01 9 19.8 1.98 10 20.2 2.02","title":"Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#summary-statistics","text":"Mean period: \\[ \\bar{T} = \\frac{1}{n} \\sum_{i=1}^{n} T_i = 2.0040 \\ \\text{s} \\] Standard deviation: \\[ \\sigma = \\sqrt{ \\frac{1}{n - 1} \\sum_{i=1}^{n} (T_i - \\bar{T})^2 } = 0.0126 \\ \\text{s} \\] Uncertainty in the mean period: \\[ \\delta \\bar{T} = \\frac{\\sigma}{\\sqrt{n}} = 0.0040 \\ \\text{s} \\] These results indicate that the measurements are quite consistent. The low standard deviation and uncertainty demonstrate that the data is reliable.","title":"Summary Statistics"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-gravitational-acceleration","text":"Using the formula for a simple pendulum: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] Plugging in values: \\( L = 1.000 \\ \\text{m} \\) \\( \\bar{T} = 2.0040 \\ \\text{s} \\) We get: \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0040)^2} \\approx 9.8367 \\ \\text{m/s}^2 \\]","title":"1. Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-propagation-of-uncertainty","text":"Let: \\( \\delta L = 0.005 \\ \\text{m} \\) \\( \\delta \\bar{T} = 0.0040 \\ \\text{s} \\) Then: \\[ \\delta g = g \\cdot \\sqrt{ \\left( \\frac{\\delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\delta \\bar{T}}{\\bar{T}} \\right)^2 } \\] \\[ \\delta g \\approx 9.8367 \\cdot \\sqrt{ \\left( \\frac{0.005}{1.000} \\right)^2 + \\left( 2 \\cdot \\frac{0.0040}{2.0040} \\right)^2 } \\approx 0.0614 \\ \\text{m/s}^2 \\]","title":"2. Propagation of Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\[ g = 9.84 \\pm 0.06 \\ \\text{m/s}^2 \\]","title":"Final Result:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code","text":"import numpy as np # Measured times for 10 oscillations (in seconds) T10 = np.array([20.1, 19.9, 20.0, 20.2, 20.0, 20.1, 20.0, 20.1, 19.8, 20.2]) L = 1.000 # pendulum length in meters delta_L = 0.005 # uncertainty in length # Calculations T_single = T10 / 10 T_mean = np.mean(T_single) sigma = np.std(T10, ddof=1) delta_T10 = sigma / np.sqrt(len(T10)) delta_T = delta_T10 / 10 # Gravity and uncertainty g = 4 * np.pi**2 * L / T_mean**2 delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T_mean)**2) print(f\"Mean T = {T_mean:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2 \u00b1 {delta_g:.4f}\")","title":"Python Code"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}