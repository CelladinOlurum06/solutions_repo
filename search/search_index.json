{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Projectile Motion Projectile motion follows Newton's laws under constant acceleration due to gravity. The basic equations for a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) from the horizontal are: Equations of Motion Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion under gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Time of Flight The total time of flight can be found by setting \\( y(t) = 0 \\) (when the projectile returns to the ground): $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range of the Projectile The horizontal range is given by: $$ R = v_0 \\cos(\\theta) \\cdot t_f $$ Substituting \\( t_f \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on both the initial velocity and the launch angle. 2. Analysis of the Range The maximum range occurs when \\( \\sin(2\\theta) = 1 \\) , i.e., at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases the range quadratically. Increasing \\( g \\) (e.g., on planets with stronger gravity) decreases the range. 3. Practical Applications Sports : Optimization of throwing angles in javelin, shot put, and soccer. Engineering : Ballistics and missile trajectory predictions. Astrophysics : Calculations for planetary landings, where gravity varies. 4. Implementation in Python ```python import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees Compute range for each angle ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g Find the angle with the maximum range optimal_angle = angles[np.argmax(ranges)] max_range = max(ranges) Plot plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=\"Projectile Range\") plt.axvline(x=optimal_angle, color='r', linestyle=\"--\", label=f\"Max Range at {optimal_angle:.1f}\u00b0\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() print(f\"Maximum range of {max_range:.2f} meters occurs at {optimal_angle:.1f} degrees.\")","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-projectile-motion","text":"Projectile motion follows Newton's laws under constant acceleration due to gravity. The basic equations for a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) from the horizontal are:","title":"Governing Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion (constant velocity): $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion (accelerated motion under gravity): $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The total time of flight can be found by setting \\( y(t) = 0 \\) (when the projectile returns to the ground): $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The horizontal range is given by: $$ R = v_0 \\cos(\\theta) \\cdot t_f $$ Substituting \\( t_f \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on both the initial velocity and the launch angle.","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The maximum range occurs when \\( \\sin(2\\theta) = 1 \\) , i.e., at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases the range quadratically. Increasing \\( g \\) (e.g., on planets with stronger gravity) decreases the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimization of throwing angles in javelin, shot put, and soccer. Engineering : Ballistics and missile trajectory predictions. Astrophysics : Calculations for planetary landings, where gravity varies.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#compute-range-for-each-angle","text":"ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g","title":"Compute range for each angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#find-the-angle-with-the-maximum-range","text":"optimal_angle = angles[np.argmax(ranges)] max_range = max(ranges)","title":"Find the angle with the maximum range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot","text":"plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=\"Projectile Range\") plt.axvline(x=optimal_angle, color='r', linestyle=\"--\", label=f\"Max Range at {optimal_angle:.1f}\u00b0\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() print(f\"Maximum range of {max_range:.2f} meters occurs at {optimal_angle:.1f} degrees.\")","title":"Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega_d \\) is the driving frequency. For small angles, we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega_d t) \\] Resonance and Energy Considerations Resonance occurs when the driving frequency matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ The energy in the system fluctuates due to damping and external forcing, leading to phenomena such as periodic, quasiperiodic, and chaotic motion. 2. Implementation in Python ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega_d = 2.0 # driving frequency Differential equation for the forced damped pendulum def forced_damped_pendulum(t, y, b, A, omega_d): theta, omega = y dydt = [ omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega_d t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega_d \\) is the driving frequency. For small angles, we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega_d t) \\]","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-energy-considerations","text":"Resonance occurs when the driving frequency matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ The energy in the system fluctuates due to damping and external forcing, leading to phenomena such as periodic, quasiperiodic, and chaotic motion.","title":"Resonance and Energy Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-implementation-in-python","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"2. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega_d = 2.0 # driving frequency","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation-for-the-forced-damped-pendulum","text":"def forced_damped_pendulum(t, y, b, A, omega_d): theta, omega = y dydt = [ omega, -b * omega - (g / L) * np.sin(theta) + A * np.cos(","title":"Differential equation for the forced damped pendulum"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation Kepler\u2019s Third Law Kepler\u2019s Third Law states that for a body orbiting another in a circular orbit, the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( R \\) : where: - \\( T \\) is the orbital period, - \\( R \\) is the orbital radius, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. Rearranging for \\( T \\) : \\[ T = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] This equation shows that the orbital period increases with the radius. 2. Real-World Implications Determining planetary masses: By measuring the period and radius of a moon orbiting a planet, the mass of the planet can be calculated. Satellite Orbits: Engineers use Kepler\u2019s laws to design stable orbits for communication and GPS satellites. Exoplanet Discovery: Astronomers use Kepler\u2019s Third Law to estimate the distance and mass of exoplanets by analyzing their orbital periods. 3. Implementation in Python import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R_values = np.linspace(7e6, 4e8, 100) # Orbital radii from 7,000 km to 400,000 km # Calculate orbital periods T_values = 2 * np.pi * np.sqrt(R_values**3 / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(8, 5)) plt.plot(R_values**3, T_values**2, label='$T^2 \\propto R^3$', color='b') plt.xlabel('$R^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title('Kepler\u2019s Third Law: $T^2$ vs $R^3$') plt.legend() plt.grid() plt.show() 4. Discussion on Extensions Elliptical Orbits: While this derivation assumes circular orbits, Kepler\u2019s Third Law extends to elliptical orbits by using the semi-major axis instead of \\( R \\) . Gravitational Interactions: Multi-body systems introduce perturbations that modify orbital periods slightly. Relativistic Effects: At very high masses or velocities, general relativity modifies the gravitational interactions beyond Newtonian predictions. 5. Conclusion This analysis confirms Kepler\u2019s Third Law through theoretical derivation and computational modeling. The relationship between \\( T^2 \\) and \\( R^3 \\) is essential in astronomy, satellite mechanics, and astrophysics, providing a fundamental link between motion and gravity.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler\u2019s Third Law states that for a body orbiting another in a circular orbit, the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( R \\) : where: - \\( T \\) is the orbital period, - \\( R \\) is the orbital radius, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. Rearranging for \\( T \\) : \\[ T = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] This equation shows that the orbital period increases with the radius.","title":"Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-implications","text":"Determining planetary masses: By measuring the period and radius of a moon orbiting a planet, the mass of the planet can be calculated. Satellite Orbits: Engineers use Kepler\u2019s laws to design stable orbits for communication and GPS satellites. Exoplanet Discovery: Astronomers use Kepler\u2019s Third Law to estimate the distance and mass of exoplanets by analyzing their orbital periods.","title":"2. Real-World Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R_values = np.linspace(7e6, 4e8, 100) # Orbital radii from 7,000 km to 400,000 km # Calculate orbital periods T_values = 2 * np.pi * np.sqrt(R_values**3 / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(8, 5)) plt.plot(R_values**3, T_values**2, label='$T^2 \\propto R^3$', color='b') plt.xlabel('$R^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title('Kepler\u2019s Third Law: $T^2$ vs $R^3$') plt.legend() plt.grid() plt.show()","title":"3. Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-discussion-on-extensions","text":"Elliptical Orbits: While this derivation assumes circular orbits, Kepler\u2019s Third Law extends to elliptical orbits by using the semi-major axis instead of \\( R \\) . Gravitational Interactions: Multi-body systems introduce perturbations that modify orbital periods slightly. Relativistic Effects: At very high masses or velocities, general relativity modifies the gravitational interactions beyond Newtonian predictions.","title":"4. Discussion on Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"This analysis confirms Kepler\u2019s Third Law through theoretical derivation and computational modeling. The relationship between \\( T^2 \\) and \\( R^3 \\) is essential in astronomy, satellite mechanics, and astrophysics, providing a fundamental link between motion and gravity.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"# Problem 2 # \ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities \ud83c\udfaf Motivation Space travel depends critically on understanding the gravitational forces of celestial bodies and the energy required to overcome them. Concepts such as escape velocity and cosmic velocities define the speed thresholds necessary for different types of motion \u2014 from stable orbiting to escaping a planet, or even a solar system entirely. These are not just theoretical physics concepts, but real-world tools used in designing missions, launching satellites, planning interplanetary trips, and one day \u2014 perhaps \u2014 achieving interstellar travel. \ud83c\udf0d Definitions of Cosmic Velocities In classical mechanics and astrodynamics, three main types of \"cosmic velocities\" are defined, each corresponding to a specific threshold in orbital mechanics: 1. \ud83d\udef0\ufe0f First Cosmic Velocity ( \\(v_1\\) ) \u2013 Orbital Velocity Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body (ignoring atmosphere). Physical Interpretation: If a spacecraft reaches this velocity tangential to the surface, it will fall around the planet instead of onto it \u2014 achieving orbit. Formula: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body (kg) \\(R\\) is the radius of the celestial body (m) 2. \ud83d\ude80 Second Cosmic Velocity ( \\(v_2\\) ) \u2013 Escape Velocity Definition: The minimum velocity required to completely escape the gravitational pull of a celestial body without further propulsion. Physical Interpretation: At this velocity, the total mechanical energy (kinetic + potential) of the spacecraft becomes zero \u2014 it can reach infinity with zero velocity. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 $$ 3. \ud83c\udf0c Third Cosmic Velocity ( \\(v_3\\) ) \u2013 Interstellar Escape Velocity Definition: The speed needed to escape both the planet\u2019s gravity and the gravity of its parent star (e.g., the Sun), and leave the solar system. Physical Interpretation: A spacecraft launched from Earth would need additional energy to escape not only Earth\u2019s gravity but also the Sun\u2019s gravitational influence. Note: \\(v_3\\) depends on the orbital velocity of the planet around the star and the relative direction of launch (same or opposite to orbital motion). It's generally derived from the total energy needed to reach the star system\u2019s edge. \ud83d\udcd0 Mathematical Background Gravitational Potential Energy: \\[ U = -\\frac{GMm}{r} \\] Kinetic Energy: \\[ K = \\frac{1}{2}mv^2 \\] Setting total mechanical energy \\(E = K + U = 0\\) gives the escape condition: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} $$ This is the essence of escape velocity ( \\(v_2\\) ). For orbital motion, we only need to balance centripetal and gravitational forces: $$ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} = v_1 $$ \ud83c\udf0d Cosmic Velocity Calculations To calculate the first and second cosmic velocities , we use the following physics equations: First Cosmic Velocity (circular orbit velocity): \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (escape velocity): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Where: \\( G \\) is the universal gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2} \\) \\( M \\) is the mass of the celestial body (in kg) \\( R \\) is the radius of the celestial body (in meters) We apply these formulas to the following celestial bodies: - \ud83c\udf0d Earth - \u2642\ufe0f Mars - \u2643 Jupiter The resulting velocities are visualized using bar charts to compare the gravitational environments of each planet.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Space travel depends critically on understanding the gravitational forces of celestial bodies and the energy required to overcome them. Concepts such as escape velocity and cosmic velocities define the speed thresholds necessary for different types of motion \u2014 from stable orbiting to escaping a planet, or even a solar system entirely. These are not just theoretical physics concepts, but real-world tools used in designing missions, launching satellites, planning interplanetary trips, and one day \u2014 perhaps \u2014 achieving interstellar travel.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"In classical mechanics and astrodynamics, three main types of \"cosmic velocities\" are defined, each corresponding to a specific threshold in orbital mechanics:","title":"\ud83c\udf0d Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1-orbital-velocity","text":"Definition: The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body (ignoring atmosphere). Physical Interpretation: If a spacecraft reaches this velocity tangential to the surface, it will fall around the planet instead of onto it \u2014 achieving orbit. Formula: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: \\(G\\) is the gravitational constant: \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body (kg) \\(R\\) is the radius of the celestial body (m)","title":"1. \ud83d\udef0\ufe0f First Cosmic Velocity (\\(v_1\\)) \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity","text":"Definition: The minimum velocity required to completely escape the gravitational pull of a celestial body without further propulsion. Physical Interpretation: At this velocity, the total mechanical energy (kinetic + potential) of the spacecraft becomes zero \u2014 it can reach infinity with zero velocity. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\cdot v_1 $$","title":"2. \ud83d\ude80 Second Cosmic Velocity (\\(v_2\\)) \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-interstellar-escape-velocity","text":"Definition: The speed needed to escape both the planet\u2019s gravity and the gravity of its parent star (e.g., the Sun), and leave the solar system. Physical Interpretation: A spacecraft launched from Earth would need additional energy to escape not only Earth\u2019s gravity but also the Sun\u2019s gravitational influence. Note: \\(v_3\\) depends on the orbital velocity of the planet around the star and the relative direction of launch (same or opposite to orbital motion). It's generally derived from the total energy needed to reach the star system\u2019s edge.","title":"3. \ud83c\udf0c Third Cosmic Velocity (\\(v_3\\)) \u2013 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-background","text":"","title":"\ud83d\udcd0 Mathematical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-potential-energy","text":"\\[ U = -\\frac{GMm}{r} \\]","title":"Gravitational Potential Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#kinetic-energy","text":"\\[ K = \\frac{1}{2}mv^2 \\] Setting total mechanical energy \\(E = K + U = 0\\) gives the escape condition: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} $$ This is the essence of escape velocity ( \\(v_2\\) ). For orbital motion, we only need to balance centripetal and gravitational forces: $$ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} = v_1 $$","title":"Kinetic Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocity-calculations","text":"To calculate the first and second cosmic velocities , we use the following physics equations: First Cosmic Velocity (circular orbit velocity): \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity (escape velocity): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Where: \\( G \\) is the universal gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\cdot \\text{kg}^{-1} \\cdot \\text{s}^{-2} \\) \\( M \\) is the mass of the celestial body (in kg) \\( R \\) is the radius of the celestial body (in meters) We apply these formulas to the following celestial bodies: - \ud83c\udf0d Earth - \u2642\ufe0f Mars - \u2643 Jupiter The resulting velocities are visualized using bar charts to compare the gravitational environments of each planet.","title":"\ud83c\udf0d Cosmic Velocity Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth \ud83c\udfaf Motivation When a payload is released from a spacecraft near Earth, its future motion depends entirely on its initial conditions \u2014 position, velocity, and the local gravitational field. The resulting path may be: A suborbital fall back to Earth, A stable circular or elliptical orbit , A parabolic path (exact escape), Or a hyperbolic trajectory (true escape from Earth's gravity). Understanding and predicting these trajectories is critical for: Designing satellite deployments, Planning reentry operations, Performing interplanetary injections. \ud83d\udcd0 Physical Background We assume that the only force acting on the payload is Earth's gravity , modeled by Newton's Law of Universal Gravitation . Newton's Law of Gravitation: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2 \\) is the gravitational constant, \\( M \\) is the mass of the Earth, \\( m \\) is the mass of the payload, \\( r \\) is the distance from the Earth's center, \\( \\hat{r} \\) is the unit vector pointing from the payload toward the center of Earth. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] Thus, the acceleration depends only on position, not mass \u2014 so the trajectory is independent of the payload's mass . \ud83e\udde0 Theoretical Velocity Thresholds Let \\( R \\) be Earth's radius and \\( h \\) the altitude of release. Then the radial distance is: \\[ r = R + h \\] We define three key velocity thresholds at altitude \\( r \\) : 1. Circular Orbit Velocity: The velocity needed to maintain a circular orbit at radius \\( r \\) : \\[ v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}} \\] 2. Escape Velocity: The minimum velocity needed to escape Earth\u2019s gravity (assuming no further propulsion): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\cdot v_{\\text{circular}} \\] \ud83e\uddee Numerical Simulation Using numerical integration (e.g., Runge-Kutta method via scipy.integrate.solve_ivp ), we simulate the path of the payload for various initial velocities and directions. Initial Conditions: Altitude: \\( h = 300\\,\\text{km} \\) Initial position: \\( [r_0, 0] \\) Initial velocities: Suborbital : \\( v < v_{\\text{circular}} \\) Circular Orbit : \\( v = v_{\\text{circular}} \\) Escape : \\( v \\geq v_{\\text{escape}} \\) \ud83d\udcbb Python Implementation (Sample Code) ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay] Initial altitude altitude = 300e3 r0 = R + altitude Velocity thresholds v_circular = np.sqrt(G * M / r0) v_escape = np.sqrt(2) * v_circular Scenarios scenarios = { \"Suborbital\": [r0, 0, 0, 5000], \"Circular Orbit\": [r0, 0, 0, v_circular], \"Escape Trajectory\": [r0, 0, 0, v_escape] } Time and simulation t_span = (0, 10000) t_eval = np.linspace(*t_span, 2000) Plotting plt.figure(figsize=(10, 10)) for label, state0 in scenarios.items(): sol = solve_ivp(gravity, t_span, state0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[1] plt.plot(x / 1000, y / 1000, label=label) Earth theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1000 earth_y = R * np.sin(theta) / 1000 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') plt.title(\"Trajectories of a Freely Released Payload\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its future motion depends entirely on its initial conditions \u2014 position, velocity, and the local gravitational field. The resulting path may be: A suborbital fall back to Earth, A stable circular or elliptical orbit , A parabolic path (exact escape), Or a hyperbolic trajectory (true escape from Earth's gravity). Understanding and predicting these trajectories is critical for: Designing satellite deployments, Planning reentry operations, Performing interplanetary injections.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-background","text":"We assume that the only force acting on the payload is Earth's gravity , modeled by Newton's Law of Universal Gravitation .","title":"\ud83d\udcd0 Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2 \\) is the gravitational constant, \\( M \\) is the mass of the Earth, \\( m \\) is the mass of the payload, \\( r \\) is the distance from the Earth's center, \\( \\hat{r} \\) is the unit vector pointing from the payload toward the center of Earth. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] Thus, the acceleration depends only on position, not mass \u2014 so the trajectory is independent of the payload's mass .","title":"Newton's Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-velocity-thresholds","text":"Let \\( R \\) be Earth's radius and \\( h \\) the altitude of release. Then the radial distance is: \\[ r = R + h \\] We define three key velocity thresholds at altitude \\( r \\) :","title":"\ud83e\udde0 Theoretical Velocity Thresholds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-circular-orbit-velocity","text":"The velocity needed to maintain a circular orbit at radius \\( r \\) : \\[ v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}} \\]","title":"1. Circular Orbit Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-escape-velocity","text":"The minimum velocity needed to escape Earth\u2019s gravity (assuming no further propulsion): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\cdot v_{\\text{circular}} \\]","title":"2. Escape Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Using numerical integration (e.g., Runge-Kutta method via scipy.integrate.solve_ivp ), we simulate the path of the payload for various initial velocities and directions.","title":"\ud83e\uddee Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Altitude: \\( h = 300\\,\\text{km} \\) Initial position: \\( [r_0, 0] \\) Initial velocities: Suborbital : \\( v < v_{\\text{circular}} \\) Circular Orbit : \\( v = v_{\\text{circular}} \\) Escape : \\( v \\geq v_{\\text{escape}} \\)","title":"Initial Conditions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation-sample-code","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"\ud83d\udcbb Python Implementation (Sample Code)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-acceleration","text":"def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay]","title":"Gravitational acceleration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-altitude","text":"altitude = 300e3 r0 = R + altitude","title":"Initial altitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#velocity-thresholds","text":"v_circular = np.sqrt(G * M / r0) v_escape = np.sqrt(2) * v_circular","title":"Velocity thresholds"},{"location":"1%20Physics/2%20Gravity/Problem_3/#scenarios","text":"scenarios = { \"Suborbital\": [r0, 0, 0, 5000], \"Circular Orbit\": [r0, 0, 0, v_circular], \"Escape Trajectory\": [r0, 0, 0, v_escape] }","title":"Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-and-simulation","text":"t_span = (0, 10000) t_eval = np.linspace(*t_span, 2000)","title":"Time and simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting","text":"plt.figure(figsize=(10, 10)) for label, state0 in scenarios.items(): sol = solve_ivp(gravity, t_span, state0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[1] plt.plot(x / 1000, y / 1000, label=label)","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/#earth","text":"theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) / 1000 earth_y = R * np.sin(theta) / 1000 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') plt.title(\"Trajectories of a Freely Released Payload\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when circular ripples from different points meet, forming regions of amplification (constructive interference) and cancellation (destructive interference). Understanding such patterns deepens our grasp of wave behavior, coherence, and phase relationships. In this study, we place point sources at the vertices of a regular polygon to explore interference using wave superposition. Problem Setup We simulate wave interference from 5 coherent point sources placed at the vertices of a regular pentagon . Each source emits circular waves with the same amplitude, frequency, and wavelength. Wave Equation A circular wave from a point source at \\((x_i, y_i)\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source \\(i\\) The total wave displacement is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] Assumptions Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) All waves are coherent (same phase) Regular pentagon centered at the origin Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength frequency = 1.0 # Frequency k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency t = 0 # Time (snapshot) # Polygon settings N = 5 # Number of sources (regular pentagon) radius = 3.0 # Distance from center to each vertex # Generate source positions (vertices of regular polygon) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid for simulation x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate total wave displacement Psi = np.zeros_like(X) for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) Psi += A * np.cos(k * r - omega * t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Psi, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Wave Sources') plt.title(\"Interference Pattern from 5 Point Sources (Pentagon)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when circular ripples from different points meet, forming regions of amplification (constructive interference) and cancellation (destructive interference). Understanding such patterns deepens our grasp of wave behavior, coherence, and phase relationships. In this study, we place point sources at the vertices of a regular polygon to explore interference using wave superposition.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"We simulate wave interference from 5 coherent point sources placed at the vertices of a regular pentagon . Each source emits circular waves with the same amplitude, frequency, and wavelength.","title":"Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"A circular wave from a point source at \\((x_i, y_i)\\) is: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source \\(i\\) The total wave displacement is: \\[ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions","text":"Amplitude \\(A = 1.0\\) Wavelength \\(\\lambda = 1.0\\) Frequency \\(f = 1.0\\) All waves are coherent (same phase) Regular pentagon centered at the origin","title":"Assumptions"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Simulation parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength frequency = 1.0 # Frequency k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency t = 0 # Time (snapshot) # Polygon settings N = 5 # Number of sources (regular pentagon) radius = 3.0 # Distance from center to each vertex # Generate source positions (vertices of regular polygon) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid for simulation x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate total wave displacement Psi = np.zeros_like(X) for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) Psi += A * np.cos(k * r - omega * t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Psi, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter(*zip(*source_positions), color='red', label='Wave Sources') plt.title(\"Interference Pattern from 5 Point Sources (Pentagon)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Understanding this force is crucial in many real-world systems: - Cyclotrons accelerate particles using magnetic fields. - Mass spectrometers measure mass-to-charge ratios via curved paths. - Plasma confinement in tokamaks uses magnetic fields to control hot ionized gases. Simulating this numerically reveals how different field configurations affect particle motion \u2014 circular orbits, helices, or E\u00d7B drift. Applications of the Lorentz Force Particle Accelerators : Use strong magnetic fields to bend and focus particles (e.g., LHC). Mass Spectrometry : Ions are separated by curvature of their path (depends on m/q). Fusion Reactors (Tokamaks) : Magnetic fields confine hot plasma using helical motion. Auroras : Charged solar particles spiral along Earth's magnetic field. Electric fields ( \\(\\vec{E}\\) ) add linear acceleration, while magnetic fields ( \\(\\vec{B}\\) ) bend paths into spirals or circles. Simulation of Particle Motion We simulate using the Lorentz force law and integrate using Euler's method . Scenarios: Only \\(\\vec{B}\\) : Circular or helical motion \\(\\vec{E}\\) and \\(\\vec{B}\\) : Complex curves or drifts Crossed \\(\\vec{E} \\perp \\vec{B}\\) : E\u00d7B drift Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (along z) # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Lists to store trajectory trajectory = [r.copy()] # Euler integration loop for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) # Convert to array trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2], label='Particle Path') ax.set_title('Charged Particle Trajectory (Lorentz Force)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.legend() plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Understanding this force is crucial in many real-world systems: - Cyclotrons accelerate particles using magnetic fields. - Mass spectrometers measure mass-to-charge ratios via curved paths. - Plasma confinement in tokamaks uses magnetic fields to control hot ionized gases. Simulating this numerically reveals how different field configurations affect particle motion \u2014 circular orbits, helices, or E\u00d7B drift.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Particle Accelerators : Use strong magnetic fields to bend and focus particles (e.g., LHC). Mass Spectrometry : Ions are separated by curvature of their path (depends on m/q). Fusion Reactors (Tokamaks) : Magnetic fields confine hot plasma using helical motion. Auroras : Charged solar particles spiral along Earth's magnetic field. Electric fields ( \\(\\vec{E}\\) ) add linear acceleration, while magnetic fields ( \\(\\vec{B}\\) ) bend paths into spirals or circles.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-of-particle-motion","text":"We simulate using the Lorentz force law and integrate using Euler's method .","title":"Simulation of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios","text":"Only \\(\\vec{B}\\) : Circular or helical motion \\(\\vec{E}\\) and \\(\\vec{B}\\) : Complex curves or drifts Crossed \\(\\vec{E} \\perp \\vec{B}\\) : E\u00d7B drift","title":"Scenarios:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (along z) # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Lists to store trajectory trajectory = [r.copy()] # Euler integration loop for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) # Convert to array trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2], label='Particle Path') ax.set_title('Charged Particle Trajectory (Lorentz Force)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.legend() plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating the equivalent resistance in an electrical circuit is crucial for analyzing and optimizing system performance. Traditional methods become tedious for complex networks, but graph theory offers a structured, algorithmic approach. By modeling circuits as weighted undirected graphs: - Nodes represent junctions. - Edges represent resistors (weights = resistance in ohms). This enables us to reduce circuits using series and parallel rules systematically\u2014even in nested or cyclic configurations. Theoretical Background Series and Parallel Resistance Rules Series Resistors If two resistors are connected end-to-end: \\[ R_{eq} = R_1 + R_2 \\] Parallel Resistors If two resistors connect the same pair of nodes: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Algorithm Description Input : A weighted, undirected graph with resistance values on edges. While the graph can be simplified: Detect and reduce series nodes (degree = 2). Detect and reduce parallel edges (multiple between the same nodes). Output : The resistance between the two terminals (source and target nodes). Python Implementation (with NetworkX) import networkx as nx def reduce_series(G, node, source, target): if G.degree(node) != 2 or node in [source, target]: return False neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) return True def reduce_parallel(G): reduced = False edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: if (u, v) in seen or (v, u) in seen: continue parallels = [ d['resistance'] for _, _, d in G.edges(u, v, data=True) ] if len(parallels) > 1: R_eq = 1 / sum(1 / r for r in parallels) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=R_eq) reduced = True seen.add((u, v)) return reduced def equivalent_resistance(G, source, target): G = G.copy() while True: reduced = False for node in list(G.nodes): reduced |= reduce_series(G, node, source, target) reduced |= reduce_parallel(G) if not reduced: break return G[source][target]['resistance']","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating the equivalent resistance in an electrical circuit is crucial for analyzing and optimizing system performance. Traditional methods become tedious for complex networks, but graph theory offers a structured, algorithmic approach. By modeling circuits as weighted undirected graphs: - Nodes represent junctions. - Edges represent resistors (weights = resistance in ohms). This enables us to reduce circuits using series and parallel rules systematically\u2014even in nested or cyclic configurations.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-and-parallel-resistance-rules","text":"","title":"Series and Parallel Resistance Rules"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistors","text":"If two resistors are connected end-to-end: \\[ R_{eq} = R_1 + R_2 \\]","title":"Series Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistors","text":"If two resistors connect the same pair of nodes: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\]","title":"Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"Input : A weighted, undirected graph with resistance values on edges. While the graph can be simplified: Detect and reduce series nodes (degree = 2). Detect and reduce parallel edges (multiple between the same nodes). Output : The resistance between the two terminals (source and target nodes).","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation-with-networkx","text":"import networkx as nx def reduce_series(G, node, source, target): if G.degree(node) != 2 or node in [source, target]: return False neighbors = list(G.neighbors(node)) u, v = neighbors[0], neighbors[1] R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) return True def reduce_parallel(G): reduced = False edges = list(G.edges(data=True)) seen = set() for u, v, data in edges: if (u, v) in seen or (v, u) in seen: continue parallels = [ d['resistance'] for _, _, d in G.edges(u, v, data=True) ] if len(parallels) > 1: R_eq = 1 / sum(1 / r for r in parallels) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=R_eq) reduced = True seen.add((u, v)) return reduced def equivalent_resistance(G, source, target): G = G.copy() while True: reduced = False for node in list(G.nodes): reduced |= reduce_series(G, node, source, target) reduced |= reduce_parallel(G) if not reduced: break return G[source][target]['resistance']","title":"Python Implementation (with NetworkX)"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}